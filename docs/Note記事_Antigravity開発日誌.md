# 【開発日誌】AIエージェントとTRPG戦闘シミュレーターを作ってみた：Antigravity活用のススメ

## はじめに
個人製作でTRPG（テーブルトークRPG）の戦闘シミュレーター「**NBCBattleSimulator**」を開発しました。今回は、Google DeepMindのAdvanced Agentic Codingチームが開発したAIアシスタント「**Antigravity**」と協働して開発を進めました。
本記事では、実際にツールを作成する中で感じたAntigravityの利点と、AIを活用した開発に挑戦する初心者が注意すべきポイントをまとめます。

## 前提知識：『信長の黒い城』とツールの構成

### 『信長の黒い城』の戦闘ルール（簡易版）
『信長の黒い城』は、ダークで高難易度な世界観を持つTRPGです。戦闘も非常にシビアで、ダイス目ひとつで戦況がひっくり返ります。
- **判定方法**: 20面体サイコロ（D20）＋能力値が、目標値（DR12など）以上なら成功。
- **攻撃**: プレイヤーは「命中判定」に成功すればダメージを与えられます。
- **防御**: 敵の攻撃は自動成功扱いですが、プレイヤーは「防御判定」に成功すれば回避（または軽減）できます。失敗すればダメージを受け、**ファンブル（1の目）**を出すと防具が壊れたり、倍のダメージを受けたりします。
- **士気（Morale）**: 敵はHPが尽きるだけでなく、リーダーが死んだり仲間が減ると恐れをなして「敗走」します。

このシミュレーターは、これらのルールを忠実に再現し、「この編成で勝率は何％か？」を1000回単位で自動計算するツールです。

### ソフトウェアの構成（アーキテクチャ）
このツールは、大きく2つの層に分かれて作られています。

1.  **UI層（画面）**: Reactを使用。ボタンやログ表示など、見た目を担当。
2.  **ドメイン層（ロジック）**: 純粋なTypeScriptクラス。ゲームのルールそのものを記述。
    -   `Battle.ts`: ゲームマスター役。ターンの進行や勝敗判定を行う。
    -   `Team.ts`: チームの管理。士気チェック（逃走判定）などを担当。
    -   `Member.ts`: キャラクター。HPやステータスの管理。

「文脈の理解」という話で `Battle.ts` などの名前が出てきますが、これは「AIが**ゲームのルールが書かれた核心部分**を正確に特定した」と読み替えてください。

## Antigravityを使用した開発の利点

### 1. 文脈（コンテキスト）の深い理解
Antigravityの最大の特徴は、プロジェクト全体の状態を把握してくれる点です。
単に「コードを書いて」と頼むのではなく、「今の戦闘ロジックに『敗走（Rout）』のルールを追加したい」と伝えると、関連する `Battle.ts` や `Team.ts` を自ら探し出し、既存のコードスタイルに合わせて修正を提案してくれます。

例えば、今回「足軽兎（Ashigaru Rabbit）」の特殊な士気ルール（1匹でもダメージを受けたら全員敗走）を実装した際も、既存のダメージ計算処理にフックする形で自然に実装できました。

```typescript
// Battle.ts: ダメージ適用処理内への追加提案
if (target.name.startsWith('足軽兎') && result.finalDamage >= 1) {
    // 仲間を含めて敗走状態にする専用メソッドを呼び出し
    if (this.handleAshigaruRabbitRout(target)) {
        result.log += ` 仲間の悲鳴を聞き、足軽兎たちは一目散に逃げ出した！(全員敗走)`;
    }
}
```
このように、既存の構造を壊さずにピンポイントで仕様を満たすコードを書いてくれるのが強みです。

### 2. 仕様変更への柔軟な対応
個人開発では「やっぱりこうしたい」という仕様変更が頻繁に発生します。
今回、以下のような要望を出しました。
> 「武器の『弓矢』を手動選択時は選べるようにしたいが、ランダム生成のリスト（12種類）からは除外したい」

これに対し、AIはデータ構造と生成ロジックを巧みに使い分ける提案をしてくれました。

```typescript
// Presets.ts: 武器リストには13番目として登録
export const PlayerWeapons = [
    // ...
    { id: 12, name: "斬馬刀", ... },
    { id: 13, name: "弓矢", ... }, // 手動選択用に追加
];

// createHumanoid関数: ランダム生成計算
// リストには13個あるが、サイコロは12面体を使うことで自然に除外
const wRoll = Dice.roll(1, 12); 
```
「リストから消す」のではなく「抽選ロジックで制御する」という解決策は、後々の拡張性も担保されており、非常に合理的でした。

### 3. バグ特定と修正の精度
「鉄騎猪が2回攻撃してしまう」「暗黒呪いのダメージ計算がおかしい」といったバグ報告に対し、Antigravityはログ出力の追加やロジックの再確認を自律的に行います。
「ここが怪しい」と人間が当たりをつけるのと同じように、AIが仮説を立てて検証・修正してくれるため、デバッグのストレスが大幅に軽減されました。

## 初心者が注意すべき点

### 1. 指示は「具体的」かつ「論理的」に
AIは優秀ですが、行間を読みすぎることもあれば、全く読まないこともあります。
× 「戦闘をもっとリアルにして」
〇 「HPが30%を切ったユニットは、次のターンから攻撃力が半減するロジックを追加して」
TRPGのルールのように複雑なロジックを扱う場合は、数式や条件分岐を具体的に言語化して伝えることが成功の鍵です。

### 2. AIの提案（Plan）を必ず確認する
Antigravityは作業を始める前に「Implementation Plan（実装計画）」や「Task Boundary（タスク境界）」を示してくれます。
ここで「どのファイルを」「どう変えるつもりか」を確認しましょう。意図と違うファイルをいじろうとしていたら、その時点で修正を指示することで、手戻りを防げます。

### 3. 「検証（Verification）」は人間の目で
AIが「修正しました」と言っても、本当に正しい挙動になっているかは人間が確認する必要があります。
特に確率計算や特殊な判定（ファンブル処理など）は、エッジケースでバグが残ることがあります。
今回の開発でも、実際に動かしてログを確認し、「あ、この計算式だと防御側が有利すぎる」といった微調整を何度も行いました。AIを過信せず、あくまで「優秀なパートナー」として接するのが良いでしょう。

## まとめ
Antigravityとの開発体験は、まるで熟練のエンジニアが隣にいてくれるような安心感がありました。
特にTRPGのような「数値」と「ルール」が複雑に絡み合うツールの開発において、全体像を把握しながら細部を詰めてくれる能力は非常に強力です。
プログラミング初心者の方も、まずは「やりたいこと」を具体的に書き出し、AIと一緒に小さな機能から作り始めてみてはいかがでしょうか。
